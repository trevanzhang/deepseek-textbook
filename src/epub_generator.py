"""
    "若提示未找到pandoc！请按以下方式配置：\n"
    "1. 下载安装pandoc: https://pandoc.org/installing.html\n"
    "2. 设置环境变量：\n"
    "   - 例如：C:\\Program Files\\Pandoc\\pandoc.exe\n"
    "   - 或者将pandoc所在目录添加到系统PATH中\n"
"""

import os
import logging
import pypandoc
from pathlib import Path
from typing import List, Dict
import yaml
from datetime import datetime

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('epub_generator.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class EpubGenerator:
    def __init__(self):
        self.textbook_dir = Path('textbook')
        self.output_dir = Path('epub')
        self.output_dir.mkdir(exist_ok=True)

    def get_textbooks(self) -> Dict[str, List[Path]]:
        """获取所有教材的markdown文件，按创建时间排序"""
        textbooks = {}
        for textbook_dir in self.textbook_dir.iterdir():
            if textbook_dir.is_dir():
                # 获取所有markdown文件并按创建时间排序
                files = list(textbook_dir.glob('*.md'))
                files.sort(key=lambda x: x.stat().st_mtime)  # 使用最后修改时间排序
                if files:
                    textbooks[textbook_dir.name] = files
                    logger.info(f"教材 {textbook_dir.name} 的章节顺序：{[f.stem for f in files]}")
        return textbooks

    def create_metadata(self, title: str) -> str:
        """创建epub元数据文件"""
        metadata = {
            'title': title,
            'author': 'Generated by DeepSeek',
            'date': datetime.now().strftime('%Y-%m-%d'),
            'language': 'zh-CN'
        }
        
        metadata_file = self.output_dir / f"{title}_metadata.yaml"
        with open(metadata_file, 'w', encoding='utf-8') as f:
            yaml.dump(metadata, f, allow_unicode=True, default_flow_style=False)
        
        return str(metadata_file)

    def merge_markdown_files(self, files: List[Path], output_file: Path) -> Path:
        """合并markdown文件"""
        merged_content = ['# 目录\n\n']  # 添加目录标题
        for file in files:
            with open(file, 'r', encoding='utf-8') as f:
                content = f.read()
                # 确保每个章节都以二级标题开始
                if not content.startswith('## '):
                    content = f'## {file.stem}\n\n{content}'
                merged_content.append(content)
                merged_content.append('\n\n---\n\n')  # 添加分隔符

        temp_md = self.output_dir / f"{output_file.stem}_temp.md"
        with open(temp_md, 'w', encoding='utf-8') as f:
            f.write('\n'.join(merged_content))

        return temp_md

    def generate_epub(self):
        """生成epub文件"""
        try:
            textbooks = self.get_textbooks()
            if not textbooks:
                logger.warning("未找到任何教材文件！")
                return

            for title, files in textbooks.items():
                try:
                    logger.info(f"开始处理教材: {title}")
                    
                    # 创建元数据文件
                    metadata_file = self.create_metadata(title)
                    
                    # 合并markdown文件
                    merged_md = self.merge_markdown_files(files, Path(title))
                    
                    # 生成epub
                    output_epub = self.output_dir / f"{title}.epub"
                    pypandoc.convert_file(
                        str(merged_md),
                        'epub',
                        outputfile=str(output_epub),
                        extra_args=[
                            f'--metadata-file={metadata_file}',
                            '--toc',  # 添加目录
                            '--toc-depth=3',  # 增加目录深度
                            '--split-level=2',  # 设置章节级别
                            # '--epub-chapter-level=2',  # 设置章节级别
                            # '--number-sections',  # 添加章节编号
                            '--standalone',  # 生成完整的文档
                            '--css=style.css'  # 添加样式表支持
                        ]
                    )
                    
                    # 清理临时文件
                    merged_md.unlink()
                    Path(metadata_file).unlink()
                    
                    logger.info(f"成功生成epub文件: {output_epub}")
                    
                except Exception as e:
                    logger.error(f"处理教材 {title} 时出错: {str(e)}")
                    continue

        except Exception as e:
            logger.error(f"生成epub过程中出错: {str(e)}")
            raise

def main():
    try:
        generator = EpubGenerator()
        generator.generate_epub()
        logger.info("所有epub文件生成完成")
    except Exception as e:
        logger.error(f"程序执行失败: {str(e)}")
        raise

if __name__ == '__main__':
    main() 